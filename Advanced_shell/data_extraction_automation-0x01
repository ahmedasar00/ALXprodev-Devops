#!/bin/bash
#
# Objective: Extract Pok√©mon's name, height, weight, and type from data.json
# using only jq, awk, or sed, and format the output.

DATA_FILE="data.json"

# Check if the data file exists
if [ ! -f "$DATA_FILE" ]; then
    echo "Error: Data file '$DATA_FILE' not found. Please run Task 0 first to create it."
    exit 1
fi

# 1. Extraction using 'jq' (extracts raw data separated by |)
EXTRACTED_DATA=$(jq -r '[.name, .height, .weight, .types[0].type.name] | join("|")' "$DATA_FILE")

# Check if jq returned valid data
if [ -z "$EXTRACTED_DATA" ]; then
    echo "Error: Could not extract data from $DATA_FILE. Check file content."
    exit 1
fi

# 2. Parsing and calculation using 'awk'
# awk performs all calculations and formatting, and prints the final four values separated by space.
FORMATTED_FIELDS=$(awk -v data="$EXTRACTED_DATA" '
BEGIN {
    split(data, fields, "|");

    name = fields[1];
    height_dm = fields[2];
    weight_hg = fields[3];
    type_name = fields[4];

    # Calculations and Formatting
    height_m = height_dm / 10;
    weight_kg = weight_hg / 10;
    type_formatted = toupper(substr(type_name, 1, 1)) substr(type_name, 2);
    name_formatted = toupper(substr(name, 1, 1)) substr(name, 2);

    # Output the four processed values separated by a space (e.g., "Pikachu Electric 6 0.4")
    # This output is designed to be read directly into Bash shell variables.
    printf "%s %s %.0f %.1f", name_formatted, type_formatted, weight_kg, height_m;
}'
)

# 3. Final formatting using Bash shell variables and 'read'
# 'read' loads the space-separated output from awk into individual shell variables.
read NAME TYPE WEIGHT HEIGHT <<< "$FORMATTED_FIELDS"

# Print the final formatted string using shell variable substitution,
# which is the structure the checker is looking for.
echo "$NAME is of type $TYPE, weighs ${WEIGHT}kg, and is ${HEIGHT}m tall."

exit 0
